# 💫 About Me:
🔭 I’m currently studying at Padang State University<br><br>🌱 I’m currently learning C Language<br><br>👩🏼‍💻My major is informatics engineering<br><br>🌷 Fun fact I love watching drakor and sleeping<br><br>"just because it's hard doesn't mean it's impossible. you can do it"


## 🌐 Socials:
[![Instagram](https://img.shields.io/badge/Instagram-%23E4405F.svg?logo=Instagram&logoColor=white)](https://instagram.com/najwaeldraa) [![Pinterest](https://img.shields.io/badge/Pinterest-%23E60023.svg?logo=Pinterest&logoColor=white)](https://pinterest.com/xowhtnao) [![YouTube](https://img.shields.io/badge/YouTube-%23FF0000.svg?logo=YouTube&logoColor=white)](https://youtube.com/@oweelisya3759) 

# 💻 Tech Stack:
![C](https://img.shields.io/badge/c-%2300599C.svg?style=plastic&logo=c&logoColor=white) ![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=plastic&logo=c%2B%2B&logoColor=white) ![Adobe Photoshop](https://img.shields.io/badge/adobe%20photoshop-%2331A8FF.svg?style=plastic&logo=adobe%20photoshop&logoColor=white) ![Canva](https://img.shields.io/badge/Canva-%2300C4CC.svg?style=plastic&logo=Canva&logoColor=white) ![Adobe Lightroom](https://img.shields.io/badge/Adobe%20Lightroom-31A8FF.svg?style=plastic&logo=Adobe%20Lightroom&logoColor=white)
# 📊 GitHub Stats:
![](https://github-readme-stats.vercel.app/api?username=najwaeldiaraot&theme=radical&hide_border=false&include_all_commits=false&count_private=false)<br/>
![](https://github-readme-stats.vercel.app/api/top-langs/?username=najwaeldiaraot&theme=radical&hide_border=false&include_all_commits=false&count_private=false&layout=compact)

## 🏆 GitHub Trophies
![](https://github-profile-trophy.vercel.app/?username=najwaeldiaraot&theme=radical&no-frame=false&no-bg=true&margin-w=4)

### ✍️ Random Dev Quote
![](https://quotes-github-readme.vercel.app/api?type=horizontal&theme=radical)

### 🔝 Top Contributed Repo
![](https://github-contributor-stats.vercel.app/api?username=najwaeldiaraot&limit=5&theme=dark&combine_all_yearly_contributions=true)

---
[![](https://visitcount.itsvg.in/api?id=najwaeldiaraot&icon=7&color=10)](https://visitcount.itsvg.in)

<!-- Proudly created with GPRM ( https://gprm.itsvg.in ) -->

# Job Sheet 1
Job Sheet 1 menjelaskan bahwa struktur data merupakan cara penyimpanan, penyusunan, dan pengaturan data di dalam media penyimpanan komputer. Merupakan representasi fakta dunia nyata yang disimpan, direkam, atau direpresentasikan dalam bentuk tulisan, suara, gambar, sinyal atau simbol. Dalam pemrograman, struktur data berarti tata letak data yang berisi kolom-kolom data, baik itu kolom yang tampak oleh pengguna (user) atau pun kolom yang hanya digunakan untuk keperluan pemrograman yang tidak tampak oleh pengguna. Struktur data dapat dikategorikan menjadi tipe data sederhana tunggal, seperti Integer, real, boolean dan karakter, serta tipe data sederhana majemuk, seperti String (kumpulan data char). Struktur data yang standar yang biasanya digunakan dibidang informatika adalah List linier (Linked List), Multilist, Stack (Tumpukan), Queue (Antrian), Tree (Pohon), dan Graph (Graf)

# Job Sheet 2
Job Sheet 2 menjelaskan bahwa array adalah suatu kumpulan nilai yang bertipe data sama, dengan masing-masing elemen array diakses menggunakan indeks. Deklarasi array dilakukan dengan menuliskan tipe data, nama array, dan ukuran array. Pointer adalah variable yang berisi alamat memory sebagai nilainya, berbeda dengan variable biasa yang berisi nilai tertentu. Deklarasi pointer dilakukan dengan menambahkan tanda asterisk (*) pada tipe data yang akan dijadikan pointer. Structure adalah kumpulan variable yang bernama objek yang serumpun, dengan tipe-tipe yang berbeda. Deklarasi structure dilakukan dengan menuliskan tipe data dan nama variable, serta mengisi nilai dari setiap variable.

# Job Sheet 3
Job Sheet 3 menjelaskan bahwa single linked list merupakan sebuah data yang berupa simpul atau node beralamat yang saling bertaut. Setiap simpul bisa menyimpan data yang mana isinya bisa char, int, string atau tipe data lainnya. Sebuah linked list sederhana terdiri dari sebuah simpul special yang hanya memiliki alamat/pointer simpul ini dinamakan HEAD, dan sebuah simpul TAIL yang tidak menuju kemanapun. Penggunaan alokasi memori memungkinkan user untuk membuat tipe data dan struktur dengan ukuran dan panjang berapapun yang disesuaikan dengan kebutuhan di dalam program. Perintah sizeof digunakan untuk mendapatkan ukuran dari berbagai tipe data, variabel, ataupun struktur. Perintah malloc() digunakan untuk mengalokasikan memori.

# Job Sheet 4
Job Sheet 4 menjelaskan bahwa doubly linked list merupakan sebuah data yang berupa simpul atau node beralamat yang saling bertaut. Setiap simpul bisa menyimpan data yang mana isinya bisa char, int, string atau tipe data lainnya. Sebuah linked list sederhana terdiri dari sebuah simpul special yang hanya memiliki alamat/pointer simpul ini dinamakan HEAD, dan sebuah simpul TAIL yang tidak menuju kemanapun.Penggunaan alokasi memori memungkinkan user untuk membuat tipe data dan struktur dengan ukuran dan panjang berapapun yang disesuaikan dengan kebutuhan di dalam program. Perintah sizeof digunakan untuk mendapatkan ukuran dari berbagai tipe data, variabel, ataupun struktur. Perintah malloc() digunakan untuk mengalokasikan memori.

# Job Sheet 5
Job Sheet 5 menjelaskan tentang teori dasar Double Linked List dan Circular Linked List. Double Linked List adalah jenis linked list yang menggunakan dua pointer dalam satu node, yang menyebabkan list melintas baik ke depan (next) maupun ke belakang (prev) atau (back). Circular Linked List adalah bentuk lain dari linked list yang memberikan fleksibilitas dalam melewatkan elemen. Circular List bisa berupa single linked list atau double linked list, tetapi tidak mempunyai tail. Pada circular list, pointer next dari elemen terakhir menunjuk ke elemen pertama dan bukan menunjuk NULL. Pada double linked circular list, pointer prev dari elemen pertama menunjuk ke elemen terakhir.

# Job Sheet 6
Job Sheet 6 menjelaskan bahwa stack adalah sebuah kumpulan data dimana data yang diletakkan di atas data yang lain. Elemen terakhir yang disimpan dalam stack menjadi elemen pertama yang diambil. Dalam praktikum ini, mahasiswa akan mempelajari penggunaan stack dalam proses komputasi, seperti menambah dan mengurangi elemen stack, mengubah elemen stack, dan memeriksa apakah stack kosong atau penuh. Selain itu Job Sheet 5 juga menjelaskan tentang implementasi stack menggunakan array dan linked list. Dalam implementasi stack menggunakan array, mahasiswa akan membuat sebuah array dengan ukuran tertentu, menambah elemen ke dalam array, dan mengurangi elemen dari array. Dalam implementasi stack menggunakan linked list, mahasiswa akan membuat sebuah node dengan data dan pointer ke node berikutnya, menambah node ke dalam linked list, dan mengurangi node dari linked list. Job sheet 5 juga menjelaskan tentang penggunaan fungsi push, pop, peek, isFull, isEmpty, clear, dan driver program untuk mengetes fungsi-fungsi tersebut. Dalam praktikum ini, mahasiswa akan mempelajari cara menggunakan fungsi push untuk menambah elemen ke stack, fungsi pop untuk mengurangi elemen dari stack, fungsi peek untuk mengecek elemen paling atas stack tanpa menghapusnya, fungsi isFull untuk mengecek apakah stack penuh, fungsi isEmpty untuk mengecek apakah stack kosong, dan fungsi clear untuk mengosongkan stack.

# Job Sheet 7
![Alt text](pict.js 7.jpg)
Job Sheet 7 menjelaskan tentang antrian (queue) dalam praktikum Struktur Data Teknik Informatika. Antrian adalah sebuah data structure yang berguna pada pemrograman. Antrian menggunakan prinsip FIFO (First-In-First-Out), dimana item yang mendapat giliran pertama adalah item yang pertama keluar. Antrian dapat menggunakan array atau linked list untuk implementasi. Antrian dapat digunakan untuk memecahkan permasalahan pemrograman, misalnya untuk menambah dan menghapus elemen dari antrian. Job Sheet 7 juga menjelaskan tentang queue dengan array dan queue dengan linked list. Pada queue dengan array, digunakan sejumlah array MAX untuk menyimpan data. Untuk queue dengan linked list, digunakan struct node untuk menyimpan data.
FIFO (First In, First Out): Elemen pertama yang masuk akan menjadi elemen pertama yang keluar.
Operasi Dasar:
Enqueue: Menambahkan elemen ke akhir antrian.
Dequeue: Menghapus elemen dari awal antrian.
Peek/Front: Melihat elemen di awal antrian tanpa menghapusnya.
IsEmpty: Memeriksa apakah antrian kosong.
Size: Mendapatkan jumlah elemen dalam antrian

# Job Sheet 8
Job Sheet 8 ini menjelaskan tentang Bubble Sort adalah algoritma pengurutan sederhana yang bekerja dengan membandingkan elemen-elemen bersebelahan dalam daftar dan menukarnya jika mereka dalam urutan yang salah. Proses ini berulang hingga seluruh daftar terurut.Cara Kerja Mulai dari elemen pertama, bandingkan elemen saat ini dengan elemen berikutnya, Jika elemen saat ini lebih besar dari elemen berikutnya, tukar kedua elemen tersebut,Lanjutkan ke pasangan elemen berikutnya dan ulangi langkah 2. Setelah satu iterasi lengkap, elemen terbesar akan "menggelembung" ke posisi akhirnya. Ulangi proses ini untuk sisa elemen hingga tidak ada lagi elemen yang perlu ditukar.
Insertion Sort adalah algoritma pengurutan yang membangun daftar terurut satu elemen pada satu waktu. Ini bekerja dengan mengiterasi daftar input dan pada setiap iterasi, menempatkan elemen saat ini ke dalam posisi yang benar di sub-daftar terurut. Cara Kerja Mulai dengan elemen kedua, anggap elemen pertama sudah terurut.
Bandingkan elemen saat ini dengan elemen sebelumnya dalam sub-daftar terurut. Geser elemen-elemen yang lebih besar dari elemen saat ini satu posisi ke kanan.
Tempatkan elemen saat ini di posisi yang benar. Ulangi proses ini untuk setiap elemen dalam daftar.

# Job Sheet 9
Job Sheet 9 ini menjelaskan tentang Selection Sort adalah algoritma pengurutan sederhana yang bekerja dengan membagi daftar menjadi dua bagian: bagian terurut dan bagian tidak terurut. Algoritma ini secara iteratif memilih elemen terkecil (atau terbesar, tergantung pada urutan) dari bagian tidak terurut dan memindahkannya ke bagian terurut. Merge Sort adalah algoritma pengurutan berbasis divide-and-conquer yang membagi daftar menjadi dua bagian, mengurutkan kedua bagian secara rekursif, dan kemudian menggabungkan (merge) kedua bagian terurut tersebut untuk menghasilkan daftar yang terurut.

# Job Sheet 10
Job Sheet 10 ini menjelaskan tentang Shell Sort adalah algoritma pengurutan yang merupakan generalisasi dari Insertion Sort. Ini mengurutkan elemen dengan jarak yang lebih besar sebelum mengurutkan elemen-elemen dengan jarak yang lebih kecil. Tujuan utama dari Shell Sort adalah untuk mengurangi jumlah pergeseran yang diperlukan oleh Insertion Sort dengan menggunakan jarak atau gap. Quick Sort adalah algoritma pengurutan berbasis divide-and-conquer yang bekerja dengan memilih elemen sebagai pivot dan membagi daftar menjadi dua sub-daftar, satu dengan elemen yang lebih kecil dari pivot dan yang lainnya dengan elemen yang lebih besar dari pivot. Sub-daftar ini kemudian diurutkan secara rekursif.

# Job Sheet 11
Job Sheet 11 ini menjelaskan tentang Linear Search adalah algoritma pencarian yang sederhana yang bekerja dengan memeriksa setiap elemen dalam daftar satu per satu hingga elemen yang dicari ditemukan atau daftar selesai diurutkan.Binary Search adalah algoritma pencarian yang efisien untuk mencari elemen dalam daftar yang sudah terurut. Algoritma ini bekerja dengan membagi daftar menjadi dua bagian dan secara iteratif atau rekursif mencari bagian yang mengandung elemen yang dicari.

# Job Sheet 12
Job Sheet 12 ini menjelaskan tentang Pohon (tree) adalah struktur data hierarkis yang terdiri dari simpul-simpul (nodes), di mana satu simpul adalah akar (root) dan sisanya adalah simpul anak yang terhubung melalui cabang (edges). Setiap simpul dapat memiliki nol atau lebih simpul anak, dan tidak ada simpul yang memiliki lebih dari satu orang tua (parent).

# Job Sheet 13
Job Sheet 13 ini menjelaskan tentang Graph (graf) adalah struktur data yang digunakan untuk merepresentasikan hubungan antar objek. Graf terdiri dari simpul (nodes atau vertices) dan sisi (edges). Sisi menghubungkan pasangan simpul dan menunjukkan hubungan antara objek-objek tersebut.
